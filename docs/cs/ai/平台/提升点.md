# 提升加速

## 计算

系统组件节点进行资源保证，实现稳定性

进行CPU核心硬绑定，提高计算效率，极大

1. CPU 3级缓存命中率低，造成的效率低下
2. 解决线程数量太多，CPU上下文切换过多的问题
3. 解决cpu限流，导致k8s环境下效率低数倍

[CPU绑核](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#configuration)

[资源保留](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/)

taskset -c 0-3

docker run --cpus 0-3

[k8s1.34](https://gemini.google.com/share/3330a07a4811)


### kubelet

```sh

#开启CPU独占绑定核心特性(1.34+新增)
cpuManagerPolicyOptions:
fullPCPUPlacement: true
#CPU管理策略必须为static(静态绑定,核心依赖)
cpuManagerPolicy: statio
#保留给kube-system等系统组件的CPU核(按需配置,比如保留0核,业务用1-7
reservedSystemCPUs: "0
```

```sh
annotations:
    # 1. 开启 CPU Burst 减少限流
    koordinator.sh/cpuBurst: '{"policy": "auto"}'
    koordinator.sh/qosClass: LSR
    # 2. 开启 L3 Cache 隔离 (如果节点支持)
    koordinator.sh/resctrl: '{"enable": true}'
    # 3. 强制 NUMA 对齐 (减少跨节点内存访问延迟)
    scheduling.koordinator.sh/numa-topology-spec: '{"numaTopologyPolicy": "SingleNUMANode"}'
    scheduling.sigs.k8s.io/cpu-bind-policy: FullPCPUs
    alibabacloud.com/lxcfs-enabled: "true"
```
### 核心原因

各种库都不能正确识别容器环境下CPU的限额，导致用的宿主机的东西，线程数量爆炸，波动放大

proc/cpuinfo和/proc/meminfo 

[LXCFS](https://www.huweihuang.com/kubernetes-notes/resource/lxcfs/lxcfs.html)

## 存储

+ Fluid
+ DrongonOSS
+ 自定义sidecar P2P拉取

进行存储架构设计，实现优先本地固态和ESSD本地处理，最后上传数据，能带来最低50%以上的提速

提升iops性能，过滤中间无效环节

## 监控进程和线程数量



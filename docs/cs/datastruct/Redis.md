Redis是当今最流行的键值对（key-value）存储数据库之一，它之所以高效，得益于其丰富且优化的数据结构。理解这些数据结构及其底层实现，是深入掌握Redis的关键。

### 字符串 (String)

**数据结构**

Redis的字符串是最基础的数据类型，它可以存储文本、序列化的对象、甚至二进制数据。

**底层实现**

* **简单动态字符串 (SDS)**: Redis并没有直接使用C语言的字符串，而是使用SDS。SDS在C语言字符串的基础上，增加了**长度信息**和**预分配空间**。
    * 长度信息使得获取字符串长度的时间复杂度从$O(N)$降到$O(1)$。
    * 预分配空间可以减少修改字符串时带来的内存重新分配开销。

---

### 哈希表 (Hash)

**数据结构**

哈希表类似于Python中的字典或Java中的HashMap，它存储键值对的集合。在Redis中，一个哈希表可以包含多个**field-value**对。

**底层实现**

* **压缩列表 (ziplist)**: 当哈希表中的键值对数量较少，且每个键和值都比较小时，Redis会使用压缩列表来存储。压缩列表是一块连续的内存空间，存储着一个个的节点，每个节点包含数据的长度和值。这种方式非常节省内存。
* **哈希表 (hashtable)**: 当哈希表中的键值对数量或大小超过了压缩列表的限制时，Redis会转换为真正的哈希表。这个哈希表由数组和链表构成，使用开放寻址法或拉链法解决哈希冲突。

---

### 列表 (List)

**数据结构**

列表是按照插入顺序排序的字符串元素集合，可以从头部或尾部进行快速插入和删除。

**底层实现**

* **压缩列表 (ziplist)**: 和哈希表类似，当列表中的元素数量和大小满足一定条件时，Redis会用压缩列表来存储。
* **双向链表 (linkedlist)**: 早期版本，当不满足使用压缩列表的条件时，使用双向链表。但链表会增加额外的内存开销。
* **快速列表 (quicklist)**: Redis 3.2版本后引入，它是双向链表和压缩列表的结合。**快速列表**的每个节点都是一个**压缩列表**，这样既能利用链表的灵活插入删除，又能利用压缩列表的内存高效。

---

### 集合 (Set)

**数据结构**

集合是无序且唯一的字符串集合。它可以用于存储不重复的元素，比如标签、用户ID等。

**底层实现**

* **整数集合 (intset)**: 如果集合中的所有元素都是整数，并且元素数量较少时，Redis会使用整数集合。整数集合本质上是一块有序的、连续的内存数组，查找效率很高。
* **哈希表 (hashtable)**: 当集合中包含非整数元素，或者元素数量超过整数集合的限制时，Redis会用哈希表来存储。哈希表的每个键都是集合的一个元素，而值是空的。

---

### 有序集合 (Sorted Set)

**数据结构**

有序集合与集合类似，但每个元素都会关联一个分数（score），Redis会根据分数对元素进行排序。

**底层实现**

* **压缩列表 (ziplist)**: 当有序集合的元素数量较少，且每个元素和分数都比较小时，使用压缩列表。
* **跳跃表 (skiplist) + 哈希表 (hashtable)**: 这是有序集合最主要的底层实现。
    * **跳跃表**: 跳跃表是一种概率性的数据结构，它通过增加多级索引来提高查找效率，可以快速定位元素。
    * **哈希表**: 哈希表用于存储成员（member）到分数（score）的映射，这样可以通过成员快速获取其分数。

掌握这些底层实现原理，能帮助你更好地选择合适的数据结构，并理解其在不同场景下的性能表现。
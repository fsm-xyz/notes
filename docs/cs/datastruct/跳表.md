### 跳表 (Skip List) 的原理

跳表是一种数据结构，它利用**概率**来维护一个有序链表，使得查找、插入和删除操作的平均时间复杂度达到 $O(\\log n)$。它的核心思想是通过**多层索引**来加快查找速度，就像我们在字典里查一个单词时，不是从头翻到尾，而是先根据字母索引快速定位到大致的范围。

一个基本的跳表由以下几部分组成：

  * **多层链表：** 跳表由多层**有序的**链表组成。最底层（Level 0）包含所有元素，是一个完整的有序链表。
  * **索引层：** 从 Level 1 到最高层，每一层都是下一层的一个**子集**。每一层的元素通过**指针**连接起来。
  * **概率晋升：** 当向跳表中插入一个新元素时，它首先被插入到最底层。然后，通过一个**随机过程**（通常是抛硬币），决定是否将这个元素晋升到上一层。如果“抛硬币”结果为正面，就将它晋升到上一层；继续抛，直到结果为反面或者达到最高层。这个随机过程确保了索引层的元素分布是**均匀且稀疏**的，从而保证了 $O(\\log n)$ 的平均时间复杂度。

**查找操作**
查找一个元素时，我们从**最高层**的链表开始，向右遍历，直到找到一个比目标元素**大**的节点。然后，我们向下移动一层，继续向右遍历。这个过程不断重复，直到我们在最底层找到或没找到目标元素。这个过程大大减少了需要比较的节点数量。

**插入和删除**
插入和删除操作与查找类似，也需要先找到对应的位置。在插入时，我们根据随机过程决定新节点需要插入到哪些层。在删除时，我们需要在所有包含该节点的层上执行删除操作。

-----

### 用 Go 语言实现跳表

下面是一个用 Go 语言实现的跳表结构，包含了基本的数据结构定义和插入、查找操作。

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

const (
    // 定义跳表的最大层数
    maxLevel = 16
    // 定义晋升到上一层的概率
    probability = 0.5
)

// Node 代表跳表中的一个节点
// 它包含值和指向下一层的指针
type Node struct {
    value int
    // forward是一个数组，存储了指向下一层节点的指针
    forward []*Node
}

// SkipList 代表跳表结构本身
type SkipList struct {
    // 头部节点
    header *Node
    // 当前跳表的最高层数
    level int
}

// newNode 创建一个新的节点
func newNode(value int, level int) *Node {
    return &Node{
        value:   value,
        forward: make([]*Node, level),
    }
}

// newSkipList 创建一个新的跳表
func newSkipList() *SkipList {
    return &SkipList{
        header: newNode(0, maxLevel),
        level:  0,
    }
}

// randomLevel 随机生成一个层数
// 这是跳表的核心，决定了新节点要插入到哪些层
func (sl *SkipList) randomLevel() int {
    level := 1
    for rand.Float64() < probability && level < maxLevel {
        level++
    }
    return level
}

// Insert 向跳表中插入一个新值
func (sl *SkipList) Insert(value int) {
    // update数组用于存储每层需要更新的节点
    update := make([]*Node, maxLevel)
    current := sl.header

    // 从最高层向下查找插入位置
    for i := sl.level; i >= 0; i-- {
        // 在当前层向右移动，直到找到一个更大的节点或到达末尾
        for current.forward[i] != nil && current.forward[i].value < value {
            current = current.forward[i]
        }
        update[i] = current
    }

    // 找到最底层(Level 0)的插入位置
    current = current.forward[0]

    // 如果该值不存在，则进行插入
    if current == nil || current.value != value {
        // 随机生成新节点的层数
        newLevel := sl.randomLevel()
        if newLevel > sl.level {
            // 如果新层数大于当前最高层，则更新最高层并设置header的指针
            for i := sl.level + 1; i < newLevel; i++ {
                update[i] = sl.header
            }
            sl.level = newLevel
        }

        // 创建新节点
        node := newNode(value, newLevel)

        // 插入新节点到所有层
        for i := 0; i < newLevel; i++ {
            node.forward[i] = update[i].forward[i]
            update[i].forward[i] = node
        }
    }
}

// Search 在跳表中查找一个值
func (sl *SkipList) Search(value int) bool {
    current := sl.header

    // 从最高层向下查找
    for i := sl.level; i >= 0; i-- {
        for current.forward[i] != nil && current.forward[i].value < value {
            current = current.forward[i]
        }
    }

    // 在最底层检查是否找到目标值
    current = current.forward[0]
    return current != nil && current.value == value
}

// printSkipList 打印跳表的所有内容，用于调试
func (sl *SkipList) printSkipList() {
    fmt.Println("-----------------SkipList-----------------")
    for i := sl.level; i >= 0; i-- {
        fmt.Printf("Level %d: ", i)
        node := sl.header.forward[i]
        for node != nil {
            fmt.Printf("%d -> ", node.value)
            node = node.forward[i]
        }
        fmt.Println("nil")
    }
    fmt.Println("------------------------------------------")
}

func main() {
    rand.Seed(time.Now().UnixNano())
    skipList := newSkipList()

    // 插入一些值
    values := []int{3, 6, 9, 2, 11, 1, 4, 8}
    for _, v := range values {
        skipList.Insert(v)
    }

    skipList.printSkipList()

    // 查找一些值
    fmt.Println("Searching for 9:", skipList.Search(9))   // 应该为 true
    fmt.Println("Searching for 10:", skipList.Search(10)) // 应该为 false
}
```

-----

### 代码解析

  * `Node` 结构体：每个节点除了包含 `value` 外，还有一个 `forward` 数组。`forward[i]` 指向当前层 `i` 的下一个节点。数组的大小由节点所在的层数决定。
  * `SkipList` 结构体：`header` 是一个虚拟的头节点，方便操作。`level` 记录当前跳表的最高层数。
  * `randomLevel()` 方法：这是跳表的核心，它使用 `rand.Float64()` 来模拟抛硬币，**以 0.5 的概率**决定是否提升到上一层。
  * `Insert()` 方法：
    1.  首先，通过从高到低的层遍历，**找到每层需要更新的节点**，并将它们存储在 `update` 数组中。
    2.  `update[i]` 存放的是在第 `i` 层插入新节点前，需要将新节点的前驱节点。
    3.  `randomLevel()` 决定新节点的层数。
    4.  如果新节点的层数高于当前最高层，更新 `SkipList.level`。
    5.  最后，将新节点插入到它需要存在的每一层中，并更新相关指针。
  * `Search()` 方法：
    1.  从最高层开始，**向右遍历**，直到找到一个比目标值大的节点，或者到达该层的末尾。
    2.  **向下移动一层**，重复这个过程。
    3.  最终在最底层（Level 0）确认是否找到目标值。

需要注意的是，上面的代码只包含了最基本的插入和查找功能。一个完整的实现还需要包含**删除**操作，其原理与插入类似，也是从高层开始找到需要删除的节点，并在所有包含它的层中进行删除和指针更新。
# MySQL


## 存储引擎对比

InnoDB：支持事务、行锁、MVCC、外键；适用高并发写场景

MyISAM：表锁、全文索引、读性能高；不支持事务，崩溃恢复弱

Memory：数据存内存，读写快但重启丢失，适合临时表

## 索引机制（核心考点）

B+树索引原理

优势：

非叶子节点仅存键值，降低树高度（减少磁盘I/O）

叶子节点双向链表，高效范围查询（如 WHERE id > 100）

vs B树：B树节点存数据，B+树数据全在叶子节点，查询更稳定

索引失效场景

对列使用函数（WHERE LEFT(name,3)=‘Tom’）

联合索引未遵循最左前缀原则（如索引(a,b,c)，条件无a则失效）

LIKE以%开头、隐式类型转换（如字符串列用数字查询）689。

索引优化策略

覆盖索引：查询列全在索引中，避免回表（如SELECT id FROM table）

索引下推：MySQL 5.6+，在存储引擎层过滤数据，减少回表次数

聚簇索引
聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种数据存储方式。

它的核心特点是：索引结构的叶子节点（Leaf Node）直接保存了完整的行数据（即整个数据页）。正因为如此，表数据本身就是按聚簇索引的结构来组织和存储的。

可以这么说：在 InnoDB 中，表就是索引，索引就是表。


## 事务和锁

### ACID与隔离级别

ACID实现：原子性, 一致性, 隔离性,  持久性

原子性 → Undo Log（回滚）

持久性 → Redo Log + Double Write Buffer（防数据丢失）110。

隔离级别：

级别	                        脏读	不可重复读	幻读
读未提交（Read Uncommitted）	✅	    ✅	    ✅
读已提交（Read Committed）	    ❌	    ✅	    ✅
可重复读（Repeatable Read）	    ❌	    ❌	    ⚠️（InnoDB通过MVCC避免）
串行化（Serializable）	        ❌	    ❌	    ❌

### 锁

悲观锁：SELECT ... FOR UPDATE（先锁行再操作） SELECT ... LOCK IN SHARE MODE
互斥锁和读写锁

记录锁，间隙锁，临界锁(组合前面的2个)

乐观锁：版本号机制（如UPDATE SET val=new_val, version=version+1 WHERE version=old_version）

死锁处理：
    死锁检测
    死锁解决

    mysql会让某个事务回滚，然后先让一个事务运行

performencScehma 下的data_locks存储锁信息

### MVCC

快照通过保存数据的多个版本来实现并发控制。

操作：不是直接覆盖旧数据，而是创建数据的一个新版本。

读操作：读的是数据在过去某个时间点的“快照”版本，而不是当前可能正在被修改的最新数据。

读者永远不会阻塞写者：读旧版本，写新版本，互不干扰。

写者永远不会阻塞读者：同上。

极大地提高了数据库的并发性能和读性能。

+ 版本链：每一行数据都有两个（或三个）隐藏字段：
    创建版本号：记录是在哪个事务中创建的。
    删除版本号：记录是在哪个事务中被删除的。
    数据库通过这些字段来维护一条数据的多个版本，形成一个“版本链”。

+ 快照读（Snapshot Read）：当一个事务开始时，数据库会给它一个“快照”，就像给这个事务拍了一张当前数据库状态的照片。这个事务后续的所有普通查询，都只会看到在这个快照创建时就已经提交的数据版本，而看不到之后其他事务新提交的数据。这就保证了可重复读的隔离级别。

+ 垃圾回收（Purge）：旧的、不再被任何事务需要的数据版本会被定期清理掉，否则数据库会无限膨胀。


好的，这是一些常见的 MySQL 面试题及答案，涵盖了基础知识、索引、查询优化、事务和高可用性等方面。

### 1. 什么是 MySQL？
**答案：** MySQL 是一个开源的关系型数据库管理系统（RDBMS），它使用 SQL（结构化查询语言）来管理和操作数据。它以其高性能、高可靠性、易用性和广泛的应用而闻名，是 Web 开发中最常用的数据库之一。

---

### 2. 什么是索引？为什么要使用索引？
**答案：** 索引是一种特殊的数据结构，它可以帮助数据库系统快速定位到表中的数据。你可以把它看作是书的目录，让你不用翻遍整本书就能找到特定章节。

使用索引的主要原因：
* **提高查询速度：** 这是索引最主要的作用。当你在 WHERE、JOIN 和 ORDER BY 子句中使用索引列时，查询性能会显著提升。
* **保证数据唯一性：** 唯一索引（UNIQUE）可以确保索引列的值不重复。
* **加速排序和分组：** 使用索引可以减少对数据的排序操作，从而提高 ORDER BY 和 GROUP BY 子句的效率。

---

### 3. MySQL 中有哪些常见的索引类型？
**答案：**
* **主键索引（PRIMARY KEY）：** 一种特殊的唯一索引，一个表只能有一个主键，不允许有 NULL 值。
* **唯一索引（UNIQUE）：** 索引列的值必须唯一，但可以有 NULL 值。
* **普通索引（NORMAL/INDEX）：** 最基本的索引，没有任何限制。
* **全文索引（FULLTEXT）：** 用于对文本内容进行模糊匹配和搜索，主要用于 MyISAM 和 InnoDB 引擎。

---

### 4. 什么是 B-Tree 和 B+Tree 索引？MySQL 为什么选择 B+Tree？
**答案：**
* **B-Tree（平衡多路查找树）：** 每个节点都存储键和数据。树中的每个节点都包含多个子节点，并且所有叶子节点都在同一层。
* **B+Tree（B-Tree 的变种）：** 非叶子节点只存储键，不存储数据。所有数据都存储在叶子节点中，并且叶子节点通过双向链表连接，形成一个有序的链表。

MySQL **选择 B+Tree** 的原因：
* **更少的 I/O 操作：** 非叶子节点只存储键，使得每个节点可以存储更多的键，从而减少了树的高度，减少了磁盘 I/O 次数。
* **有利于范围查询：** 叶子节点通过链表连接，可以轻松地进行范围查询（如 `WHERE col > 100`），而不需要从根节点重新遍历。
* **查询性能稳定：** 所有查询都必须从根节点遍历到叶子节点，所以查询性能相对稳定。

---

### 5. 什么是事务？它的四大特性（ACID）是什么？
**答案：** 事务是数据库操作的最小逻辑单元，它将一系列的数据库操作打包成一个整体，要么全部成功执行，要么全部失败回滚。

ACID 是事务的四个基本特性：
* **原子性（Atomicity）：** 一个事务中的所有操作，要么都完成，要么都不完成。
* **一致性（Consistency）：** 事务执行前后，数据库从一个一致性状态变为另一个一致性状态。
* **隔离性（Isolation）：** 多个并发执行的事务互不影响，一个事务的中间状态对其他事务是不可见的。
* **持久性（Durability）：** 一旦事务提交，其所做的修改就会永久保存到数据库中，即使系统发生故障也不会丢失。

---

### 6. MySQL 有哪些隔离级别？
**答案：** MySQL 提供了四种隔离级别，隔离级别越高，并发性能越低。
1.  **读未提交（READ UNCOMMITTED）：** 允许一个事务读取另一个事务尚未提交的数据。可能导致**脏读**。
2.  **读已提交（READ COMMITTED）：** 只允许一个事务读取另一个事务已提交的数据。解决了脏读，但可能导致**不可重复读**。
3.  **可重复读（REPEATABLE READ）：** 保证在一个事务中多次读取同一数据时，结果始终一致。解决了不可重复读，但可能导致**幻读**。
4.  **串行化（SERIALIZABLE）：** 最高隔离级别，强制事务串行执行，完全避免了脏读、不可重复读和幻读。但性能开销最大。

**MySQL 的默认隔离级别是可重复读（REPEATABLE READ）。**

---

### 7. 什么是脏读、不可重复读和幻读？
**答案：**
* **脏读（Dirty Read）：** 一个事务读取了另一个未提交事务修改的数据。如果另一个事务回滚，那么第一个事务读取的就是“脏数据”。
* **不可重复读（Non-repeatable Read）：** 一个事务多次读取同一条数据，但在此期间另一个事务修改并提交了这条数据，导致多次读取的结果不一致。
* **幻读（Phantom Read）：** 一个事务在执行两次相同的查询时，第二次查询的结果集中包含了第一次查询时不存在的记录（新增或删除）。

---

### 8. 什么是主从复制？有什么作用？
**答案：** 主从复制（Master-Slave Replication）是 MySQL 的一种高可用性方案，它允许数据从一个 MySQL 数据库服务器（主库）复制到另一个或多个服务器（从库）。

作用：
* **读写分离：** 将读请求分发到从库，将写请求留在主库，从而分担主库压力，提高数据库整体性能。
* **数据备份和灾难恢复：** 从库可以作为主库的备份，当主库出现故障时，可以快速切换到从库。
* **高可用性：** 结合其他工具（如 MHA、MGR）可以实现自动故障切换，确保服务不中断。

---

### 9. 如何进行 SQL 查询优化？
**答案：**
* **使用 EXPLAIN：** 用 `EXPLAIN` 命令分析 SQL 查询，查看查询的执行计划，如是否使用了索引、扫描了多少行等。
* **为查询条件创建索引：** 为 WHERE、JOIN 和 ORDER BY 子句中的列建立合适的索引。
* **避免全表扫描：** 尽量使用索引，避免在 WHERE 子句中对索引列进行函数操作或使用 `LIKE` 模糊查询（`%` 在开头）。
* **选择合适的字段：** 只查询需要的字段，避免使用 `SELECT *`。
* **优化 JOIN 操作：** 确保 JOIN 条件列有索引，并尽量用小表 JOIN 大表。
* **分页优化：** 使用索引分页，避免 `OFFSET` 过大导致性能问题，可以优化为 `WHERE id > last_id LIMIT N` 的方式。

---

### 10. MyISAM 和 InnoDB 有什么区别？
**答案：**
| 特性 | MyISAM | InnoDB |
| :--- | :--- | :--- |
| **事务支持** | 不支持 | **支持** |
| **锁粒度** | 表级锁 | **行级锁** |
| **外键** | 不支持 | **支持** |
| **全文索引** | 支持 | 支持 |
| **读写性能** | 读性能好，写操作会锁表 | 读写都相对平衡，并发性能高 |
| **数据存储** | 数据和索引分别存储 | 数据和索引存储在一起 |

**总结：**
* **InnoDB** 适用于绝大多数 OLTP（在线事务处理）应用，需要事务、高并发和数据完整性的场景。
* **MyISAM** 适用于读多写少、不需要事务、并发度不高的场景，如日志记录或数据仓库。但现在主流应用基本都使用 InnoDB。


# 事务

+ undo log
+ bin log
+ redo log

## 锁

+ 排他锁
+ 共享锁
+ 行锁
+ 间隙锁
+ 表锁

在 MySQL 中，了解不同类型的锁对于管理并发访问和确保数据完整性至关重要。这些锁机制决定了多个事务如何同时读写数据。下面我们来详细了解您提到的几种锁。

排他锁 (Exclusive Locks - X Locks)
排他锁，也称为写锁，是最严格的锁类型。

特点:

当一个事务获得了一行数据的排他锁后，其他任何事务都不能再对这行数据施加任何类型的锁（无论是排他锁还是共享锁），直到这个排他锁被释放。

它用于数据的修改操作，如 INSERT, UPDATE, DELETE。

用途: 确保在数据被修改时，其他事务无法同时修改它或读取到不一致的数据。

共享锁 (Shared Locks - S Locks)
共享锁，也称为读锁。

特点:

当一个事务获得了一行数据的共享锁后，其他事务可以同时对这行数据施加共享锁，但不能施加排他锁。

允许多个事务同时读取同一份数据，互不干扰。

用途: 主要用于 SELECT ... FOR SHARE（或旧版本中的 SELECT ... LOCK IN SHARE MODE）语句，确保在读取数据时，其他事务不会修改它，从而避免脏读。

行锁 (Row-Level Locks)
行锁 是 MySQL InnoDB 存储引擎特有的，它只锁定受影响的行。

特点:

粒度最小: 只锁定具体的数据行，最大限度地减少了锁的冲突，提高了并发性能。

开销较大: 相对于表锁，行锁的管理和维护开销更大，因为需要维护每个被锁定行的信息。

死锁风险: 因为事务可能按不同顺序请求不同行的锁，所以更容易发生死锁。

用途: UPDATE, DELETE, INSERT 操作在 InnoDB 中默认使用行锁。SELECT ... FOR UPDATE 和 SELECT ... FOR SHARE 也会使用行锁。

间隙锁 (Gap Locks)
间隙锁 是 InnoDB 存储引擎在 可重复读 (REPEATABLE READ) 隔离级别下为了解决 幻读 (Phantom Read) 问题而引入的一种锁机制。

特点:

锁定间隙: 不仅锁定存在的记录，还锁定记录之间的“间隙”，或者第一条记录之前的间隙，以及最后一条记录之后的间隙。

阻止插入: 主要目的是阻止其他事务在被锁定间隙内插入新的记录。

无冲突读: 间隙锁之间不冲突，意味着两个事务可以同时持有同一个间隙的间隙锁。

用途: 当进行范围查询或唯一索引查询但条件值不存在时，或者在使用索引进行范围更新/删除时，MySQL 可能会使用间隙锁来锁定索引记录之间的间隙，以防止幻读。

例如: 如果你执行 SELECT * FROM table WHERE id BETWEEN 10 AND 20 FOR UPDATE; 并且 id 是索引列，即使 id 为 15 的记录不存在，间隙锁也会锁定 (10, 20) 之间的间隙，阻止其他事务插入 id=15 的新记录。

表锁 (Table-Level Locks)
表锁 是 MySQL 中粒度最大的锁，它会锁定整个表。

特点:

粒度最大: 对整个表加锁，简单粗暴，开销最小。

并发度最低: 当一个事务对表加锁后，其他事务对该表的任何操作都可能被阻塞，大大降低了并发性能。

无死锁: 不会产生死锁，因为一次只锁定一个资源。

用途:

MyISA M存储引擎: MyISAM 存储引擎默认使用表锁，无论是读还是写操作都会加表锁。

特定操作: 在 InnoDB 中，一些 DDL (数据定义语言) 操作，如 ALTER TABLE, DROP TABLE，以及 LOCK TABLES 语句会使用表锁。

显式锁定: 可以通过 LOCK TABLES table_name READ/WRITE 语句显式地对表加锁。
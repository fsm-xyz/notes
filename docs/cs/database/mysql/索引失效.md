好的，MySQL 中索引是提升查询性能的关键，但在很多情况下，即使表中存在索引，MySQL 优化器也可能决定不使用它。理解这些情况对于数据库性能调优至关重要。

以下是 MySQL 可能不使用索引的常见情况，以及解释和示例：

### 1. 对索引列使用了函数或表达式

当你在 `WHERE` 子句中对索引列使用函数或进行计算时，MySQL 通常无法使用该列的索引。

**示例：**
假设在 `users` 表的 `birth_date` 列上有一个索引。
```sql
-- 无法使用 birth_date 索引
SELECT * FROM users WHERE YEAR(birth_date) = 1990;

-- 无法使用 index_on_column 索引
SELECT * FROM table WHERE column * 2 = 10;
```

**解决方法：**
尽量将计算或函数应用于等式的常量一侧，而不是列一侧。
```sql
-- 可以使用 birth_date 索引（如果可以的话，优化器会使用范围扫描）
SELECT * FROM users WHERE birth_date BETWEEN '1990-01-01' AND '1990-12-31';

-- 可以使用索引
SELECT * FROM table WHERE column = 10 / 2;
```

### 2. 数据类型不匹配（隐式类型转换）

如果查询条件中的数据类型与索引列定义的数据类型不匹配，MySQL 需要进行隐式类型转换，这会导致索引失效。

**示例：**
假设 `user_id` 是字符串类型（`VARCHAR`），但查询时使用了数字。
```sql
-- 假设 user_id 是 VARCHAR，但用了数字 123。MySQL 必须将每一行的 user_id 转换为数字才能比较，无法使用索引。
SELECT * FROM users WHERE user_id = 123;
```

**解决方法：**
确保查询条件中的类型与列定义的类型一致。
```sql
-- 使用字符串类型查询，可以使用索引
SELECT * FROM users WHERE user_id = '123';
```

### 3. 使用 `LIKE` 以通配符 `%` 开头

当使用 `LIKE` 进行模糊查询，且通配符 `%` 出现在字符串开头时，索引通常无法被使用。

**示例：**
假设 `last_name` 列上有索引。
```sql
-- 无法使用 last_name 索引（因为不知道开头是什么）
SELECT * FROM users WHERE last_name LIKE '%son';

-- 可以使用 last_name 索引（范围扫描）
SELECT * FROM users WHERE last_name LIKE 'John%';
```

**解决方法：**
考虑使用全文索引（FULLTEXT Index）来优化前导通配符的搜索，或者 redesign 数据 schema（但这通常很困难）。

### 4. 使用 `OR` 连接条件

如果 `OR` 连接的多个条件中，有一个列没有索引，那么即使其他列有索引，MySQL 也 often 会选择全表扫描。

**示例：**
假设 `first_name` 有索引，但 `age` 没有索引。
```sql
-- 可能无法使用 first_name 的索引，因为 age 无索引，MySQL 认为全表扫描更高效
SELECT * FROM users WHERE first_name = 'John' OR age = 30;
```

**解决方法：**
*   为 `age` 列也添加索引。
*   使用 `UNION` 或 `UNION ALL` 来拆分查询，确保每个部分都能使用索引。
    ```sql
    SELECT * FROM users WHERE first_name = 'John'
    UNION ALL
    SELECT * FROM users WHERE age = 30;
    ```
    *注意：此方法可能返回重复行，需根据业务逻辑选择 `UNION` 或 `UNION ALL`。*

### 5. 不符合最左前缀原则（针对联合索引）

对于联合索引（Composite Index），索引的顺序至关重要。查询必须从索引的最左列开始使用，才能利用该索引。

**示例：**
假设有一个联合索引 `idx_first_last` (`first_name`, `last_name`)。
```sql
-- 可以使用索引（使用 first_name 部分）
SELECT * FROM users WHERE first_name = 'John';

-- 可以使用索引（使用 first_name 和 last_name）
SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe';

-- 无法使用 idx_first_last 索引！因为跳过了 first_name
SELECT * FROM users WHERE last_name = 'Doe';
```

**解决方法：**
设计联合索引时，考虑查询的频率和顺序。如果经常需要单独按 `last_name` 查询，可能需要为其单独创建索引。

### 6. 优化器认为全表扫描更快

MySQL 优化器是基于成本（Cost-Based）的。如果它估算使用索引检索的成本比直接进行全表扫描的成本更高，就会放弃使用索引。

**常见于以下场景：**
*   **表数据量很小**：对于只有几十行或几百行的表，直接读取整个表可能比先读索引再读数据行更快。
*   **索引选择性低**：如果某列的值重复度很高（如 `gender`、`status` 等枚举字段），使用索引查出一大堆行，然后再回表，可能不如直接全表扫描。例如查询 `WHERE gender = 'M'`（假设数据一半是男性）。
*   **查询已覆盖大部分数据**：如果你要检索表中超过 ~20-30% 的数据，全表扫描可能更高效。

**解决方法：**
*   对于低选择性的列，通常不需要索引，加了优化器也不会用。
*   使用 `FORCE INDEX` 提示强制使用索引（但需谨慎，必须确认强制使用索引确实更快）。
    ```sql
    SELECT * FROM users FORCE INDEX (index_name) WHERE status = 'active';
    ```

### 7. 索引列参与 `IS NULL` 或 `IS NOT NULL` 判断

在某些 MySQL 版本和存储引擎中，对可空列的 `IS NULL` 判断可能无法有效使用索引。

**示例：**
```sql
-- 可能无法使用 index_on_column 索引
SELECT * FROM table WHERE column IS NULL;
```

**解决方法：**
这种情况比较复杂，取决于数据分布和 MySQL 版本。通常可以为 `NULL` 值较少且经常需要查询 `IS NULL` 的列建立索引。最好使用 `EXPLAIN` 来验证。

### 8. 使用 `NOT (!=, <>)` 或 `NOT IN`

负向查询通常无法高效地使用索引。
```sql
-- 通常无法高效使用索引
SELECT * FROM users WHERE status != 'active';
SELECT * FROM users WHERE id NOT IN (1, 2, 3);
```
因为这类查询需要检查几乎所有行，优化器往往会选择全表扫描。

### 如何诊断：使用 `EXPLAIN`

要确定你的查询是否使用了索引，最直接的方法是使用 `EXPLAIN` 关键字。

```sql
EXPLAIN SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe';
```

查看结果中的 `key` 字段（显示实际使用的索引）和 `type` 字段（扫描类型，`ref`, `range` 是好的，`index` 或 `ALL` 通常不好）。

**总结：**
创建索引只是第一步，确保查询语句的编写方式能够允许优化器*选择*使用索引同样重要。始终使用 `EXPLAIN` 来验证你的查询计划是否符合预期。
拥塞控制是网络传输中非常重要的一环，旨在防止网络过载，确保数据传输的稳定性和公平性。它主要通过调节发送速率来适应网络的承载能力。

拥塞控制算法主要应用于 **TCP（传输控制协议）**，因为TCP是面向连接的、可靠的协议，它需要确认接收到数据包，因此可以利用反馈机制来动态调整发送窗口大小。UDP（用户数据报协议）是无连接的、不可靠的协议，它本身不具备拥塞控制机制，发送端只管发送数据，不关心接收端是否收到。但是，一些基于UDP的上层应用协议（如QUIC）会自己实现拥塞控制。

以下是一些主流的拥塞控制算法，它们主要应用于TCP：

### 基于丢包的拥塞控制算法

这类算法主要通过检测丢包事件（超时或三次重复确认）来判断网络是否发生拥塞，并相应地降低发送速率。

* **TCP Reno：** 这是TCP拥塞控制的经典算法。它在检测到丢包时，会将拥塞窗口（cwnd）减半，然后进入 **拥塞避免** 阶段，线性增加拥塞窗口，直到再次发生丢包。
* **TCP NewReno：** 在TCP Reno的基础上进行了改进。当多个数据包在同一个往返时间内丢失时，NewReno可以更好地处理，避免多次不必要的窗口减半，从而提高吞吐量。

---

### 基于延迟的拥塞控制算法

这类算法通过测量数据包的往返时间（RTT）来判断网络拥塞情况。如果RTT显著增加，就认为网络即将拥塞，从而降低发送速率。这是一种更 proactive（主动）的方法，可以在丢包发生之前就采取措施。

* **TCP Vegas：** 这是最早的基于延迟的拥塞控制算法之一。它通过比较实际的发送速率和期望的发送速率来调整拥塞窗口。当RTT增加时，它会主动减小发送速率。
* **Cubic（CUBIC TCP）：** 这是目前Linux内核中默认的拥塞控制算法。Cubic的设计是为了在高带宽、高延迟（BDP，Bandwidth-Delay Product）网络中表现更好。它使用一个三次函数（cubic function）来探测网络的可用带宽，其窗口增长曲线更平缓，可以更有效地利用网络。

---

### 混合型或新一代拥塞控制算法

* **BBR（Bottleneck Bandwidth and Round-trip propagation time）：** 这是由Google开发的拥塞控制算法，目前也广泛应用于Linux内核和Google的QUIC协议中。BBR不同于传统的基于丢包或延迟的算法，它通过测量网络的 **瓶颈带宽（Bottleneck Bandwidth）** 和 **往返传播时间（Round-trip propagation time）** 来构建网络模型，并据此来决定发送速率。它可以更精准地利用网络，避免过度拥塞，并提供更高的吞吐量和更低的延迟。

---

### 总结

* **TCP** 协议本身自带拥塞控制机制，上述所有算法都主要用于TCP，其中 **Cubic** 和 **BBR** 是目前最常用和高效的。
* **UDP** 协议本身不提供拥塞控制，但上层应用协议可以自行实现，例如 **QUIC** 就内建了类似于BBR的拥塞控制算法。
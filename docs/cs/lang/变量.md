# 变量

Rust所有变量绑定本身都在栈上，但这个变量所代表的完整数据，则根据其类型特性，可能完全在栈上，也可能主要部分在堆上

Rust 中变量和值是分开的概念，这是 Rust 独特的设计

C/Go - 变量是内存位置

Rust - 变量是绑定

Rust：内存分配位置（栈或堆）是在编译时根据类型和所有权规则确定的，开发者有完全的控制权和预见性。

Go：内存分配位置是由编译器在编译时通过“逃逸分析”（Escape Analysis）来决定的，开发者对此没有直接的控制权。

## 基本概念

**变量（Variable）**：是内存中的一个**位置**或**容器**，有名字、类型和地址
**值（Value）**：是存储在变量中的**具体数据**

```go
var x int = 42
//  ^     ^
//  |     |
//变量名  值
```

## 不同语言中的变量-值关系

### 1. C/C++ - 直接存储模型
```c
int x = 42;        // x 直接存储值 42
int* ptr = &x;     // ptr 存储 x 的地址
```
```
内存布局：
栈: [x: 42] [ptr: 0x1000]
```

### 2. Go - 混合模型
```go
// 值类型 - 直接存储
var x int = 42           // x 直接存储 42
var arr = [3]int{1,2,3}  // arr 直接存储数组

// 引用类型 - 存储指针
var slice = []int{1,2,3}    // slice 存储指向堆的指针
var m = make(map[string]int) // m 存储指向堆的指针
```

### 3. Rust - 所有权模型
```rust
let x = 42;                    // x 拥有值 42
let s = String::from("hello"); // s 拥有 String 对象
let y = x;                     // x 的值复制给 y
let t = s;                     // s 的所有权移动给 t（s 不再有效）
```

### 4. Java/C# - 引用模型
```java
int x = 42;           // 基本类型，x 直接存储 42
Integer obj = 42;     // 引用类型，obj 存储指向对象的引用
String s = "hello";   // s 存储指向字符串对象的引用
```

## 赋值操作的不同语义

### 值拷贝 vs 引用拷贝

```go
// Go 语言示例
func assignment() {
    // 值类型 - 值拷贝
    a := 42
    b := a        // b 得到 a 的值的副本
    a = 100       // 修改 a 不影响 b
    fmt.Println(b) // 输出: 42
    
    // 引用类型 - 引用拷贝
    slice1 := []int{1, 2, 3}
    slice2 := slice1          // slice2 和 slice1 指向同一个底层数组
    slice1[0] = 100          // 修改会影响 slice2
    fmt.Println(slice2[0])   // 输出: 100
}
```

### Rust 的移动语义
```rust
fn ownership() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 的所有权移动给 s2
    // println!("{}", s1);  // 编译错误！s1 不再有效
    
    let x = 42;
    let y = x;    // i32 实现了 Copy，所以是拷贝不是移动
    println!("{}", x);  // 正常，x 仍然有效
}
```

## 变量的生命周期

### 栈变量
```go
func stackLifetime() {
    x := 42  // x 在函数开始时创建
    // ...
}  // x 在函数结束时自动销毁
```

### 堆变量
```go
func heapLifetime() *int {
    x := 42   // 逃逸分析：x 需要分配在堆上
    return &x // 返回指针，x 的生命周期延长
}  // x 在堆上，由 GC 管理
```

## 指针和引用

### Go 的指针
```go
func pointerExample() {
    x := 42
    ptr := &x     // ptr 是指向 x 的指针
    *ptr = 100    // 通过指针修改 x 的值
    fmt.Println(x) // 输出: 100
}
```

### Rust 的借用
```rust
fn borrow_example() {
    let mut x = 42;
    let r = &mut x;    // r 是 x 的可变借用
    *r = 100;          // 通过借用修改 x
    println!("{}", x); // 输出: 100
}
```

## 内存模型对比

### 值类型的内存布局
```
Go/Rust/C:
var x int32 = 42
栈: [x: 42]

Java:
int x = 42;
栈: [x: 42]
```

### 对象类型的内存布局
```
Go:
type Person struct { name string; age int }
p := Person{"Alice", 25}
栈: [p: {ptr_to_"Alice", len, age: 25}]
堆: ["Alice"]

Java:
class Person { String name; int age; }
Person p = new Person("Alice", 25);
栈: [p: ref_to_object]
堆: [Person{name: ref_to_string, age: 25}] -> ["Alice"]
```

## 实际编程中的影响

### 1. 性能考虑
```go
// 值传递 - 可能有复制开销
func processLargeStruct(s LargeStruct) { /* ... */ }

// 指针传递 - 避免复制
func processLargeStruct(s *LargeStruct) { /* ... */ }
```

### 2. 并发安全
```go
// 值类型天然并发安全（每个 goroutine 有自己的副本）
func safeConcurrent(x int) {
    go func() { x = x + 1 }() // 不会影响原始值
}

// 引用类型需要同步
func unsafeConcurrent(slice []int) {
    go func() { slice[0] = 100 }() // 可能有竞态条件
}
```

## 总结

变量和值的关系在不同语言中有不同的实现：

- **C/C++**：变量直接包含值，程序员完全控制
- **Go**：值类型直接存储，引用类型存储指针，编译器优化
- **Rust**：所有权系统，编译时保证内存安全
- **Java/C#**：基本类型存储值，对象类型存储引用

理解这些关系对于编写高效、安全的代码非常重要，特别是在涉及内存管理、性能优化和并发编程时。
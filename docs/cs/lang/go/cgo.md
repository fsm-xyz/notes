# CGO

在go里面需要调用C/C++的项目，不用重新实现

## C

+ CGO直接绑定(内联C代码, 外部C文件绑定)
+ 用[swig](https://zhuanlan.zhihu.com/p/1901700733016966835)进行绑定
+ 动态库绑定
+ 系统调用绑定

### 动态库绑定

+ 编译时链接：简单直接，性能好，但需要库在编译时可用
+ 运行时加载：更灵活，支持插件架构，但代码更复杂
+ 用第三方库：简化了动态加载过程，提供更高层次的抽象

## C++

+ 直接C++绑定
+ 通过C包装器(wrapper)
+ SWIG自动绑定
+ 动态库加载

## cgo.Handle 的优势

+ 线程安全：内部实现处理了并发问题
+ 垃圾回收安全：防止对象被意外回收
+ 类型安全：可以存储任意 Go 对象
+ 性能优化：避免了全局 map 的锁竞争
+ 内存效率：自动管理句柄的生命周期

## 线程

如果是 Go 调用 C：在同一个线程（Go 的线程）
如果是 C 创建新线程调用 Go：在C 的新线程上

+ CGO 本身不创建线程，C 代码在调用它的 OS 线程上执行
+ C 代码可以创建自己的线程，并从这些线程回调 Go 函数
+ Go 运行时会自动处理从 C 线程的回调，创建相应的 goroutine
+ 需要特别注意线程安全，使用适当的同步机制
+ 推荐使用 channel 在不同线程的 goroutine 之间通信

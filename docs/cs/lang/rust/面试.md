# Rust面试题目与答案集合

## 基础概念篇

### 1. 什么是Rust的所有权系统？为什么它很重要？

**答案：**
所有权系统是Rust最核心的特性，它通过编译时检查来管理内存，避免了垃圾回收器的开销。

**三条规则：**
- 每个值都有一个所有者（owner）
- 同一时间只能有一个所有者
- 当所有者离开作用域时，值被丢弃

**重要性：**
- 内存安全：避免空指针、缓冲区溢出、内存泄漏
- 零成本抽象：没有运行时开销
- 线程安全：防止数据竞争

### 2. 解释Rust中的借用（Borrowing）机制

**答案：**
借用允许你使用值而不获取其所有权。

**两种借用类型：**
- **不可变借用（&T）**：可以同时存在多个，只能读取数据
- **可变借用（&mut T）**：同时只能存在一个，可以修改数据

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;        // 不可变借用
    let r2 = &s;        // 多个不可变借用OK
    println!("{} {}", r1, r2);
    
    let r3 = &mut s;    // 可变借用
    r3.push_str(" world");
    println!("{}", r3);
}
```

### 3. 什么是生命周期（Lifetime）？如何使用生命周期标注？

**答案：**
生命周期是引用有效的作用域，确保引用在被使用时始终有效。

```rust
// 生命周期标注示例
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 结构体中的生命周期
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

## 高级特性篇

### 4. 解释Rust中的trait系统

**答案：**
Trait类似于其他语言中的接口，定义了类型必须实现的方法。

```rust
trait Summary {
    fn summarize(&self) -> String;
    
    // 默认实现
    fn default_summary(&self) -> String {
        String::from("(Read more...)")
    }
}

struct Article {
    title: String,
    content: String,
}

impl Summary for Article {
    fn summarize(&self) -> String {
        format!("{}: {}", self.title, self.content)
    }
}

// Trait作为参数
fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

### 5. 什么是Option和Result类型？如何使用它们？

**答案：**
这两个是Rust处理可能失败或不存在值的核心类型。

```rust
// Option用于可能不存在的值
fn divide(x: f64, y: f64) -> Option<f64> {
    if y == 0.0 {
        None
    } else {
        Some(x / y)
    }
}

// Result用于可能失败的操作
use std::fs::File;
use std::io::Error;

fn read_file(path: &str) -> Result<File, Error> {
    File::open(path)
}

// 使用模式匹配处理
match divide(10.0, 2.0) {
    Some(result) => println!("Result: {}", result),
    None => println!("Cannot divide by zero"),
}

// 使用?操作符简化错误处理
fn read_and_process() -> Result<(), Error> {
    let file = File::open("file.txt")?;
    // 处理文件...
    Ok(())
}
```

### 6. 解释Rust中的闭包（Closure）

**答案：**
闭包是可以捕获环境中变量的匿名函数。

```rust
fn main() {
    let x = 4;
    
    // 捕获环境变量
    let equal_to_x = |z| z == x;
    
    let y = 4;
    assert!(equal_to_x(y));
    
    // 三种捕获方式
    let list = vec![1, 2, 3];
    
    // FnOnce：获取所有权
    let consume = || {
        println!("From closure: {:?}", list);
        list  // 移动所有权
    };
    
    // Fn：不可变借用
    let list2 = vec![1, 2, 3];
    let borrow = || println!("From closure: {:?}", list2);
    
    // FnMut：可变借用
    let mut list3 = vec![1, 2, 3];
    let mut borrow_mut = || list3.push(4);
}
```

## 并发编程篇

### 7. Rust如何保证线程安全？

**答案：**
Rust通过类型系统和所有权模型在编译时保证线程安全。

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    // Arc：原子引用计数，允许多个所有者
    // Mutex：互斥锁，保证同时只有一个线程访问数据
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

### 8. 解释Send和Sync trait

**答案：**
这是Rust用于线程安全的两个重要marker trait：

- **Send**：类型可以安全地在线程间转移所有权
- **Sync**：类型可以安全地在线程间共享引用（&T是Send）

```rust
// 大部分类型自动实现Send和Sync
// 例外：Rc<T>不是Send，RefCell<T>不是Sync

use std::sync::Arc;
use std::thread;

fn is_send<T: Send>() {}
fn is_sync<T: Sync>() {}

fn main() {
    is_send::<i32>();           // OK
    is_sync::<i32>();           // OK
    is_send::<Arc<i32>>();      // OK
    is_sync::<Arc<i32>>();      // OK
    
    // is_send::<Rc<i32>>();    // 编译错误
}
```

## 内存管理篇

### 9. 解释智能指针：Box、Rc、Arc的区别

**答案：**

| 类型 | 所有权 | 线程安全 | 使用场景 |
|------|--------|----------|----------|
| Box<T> | 单一所有者 | 取决于T | 堆分配，递归类型 |
| Rc<T> | 多个所有者 | 不安全 | 单线程共享数据 |
| Arc<T> | 多个所有者 | 安全 | 多线程共享数据 |

```rust
use std::rc::Rc;
use std::sync::Arc;
use std::thread;

// Box：单一所有权
let b = Box::new(5);

// Rc：单线程多所有权
let rc1 = Rc::new(5);
let rc2 = Rc::clone(&rc1);

// Arc：多线程多所有权
let arc1 = Arc::new(5);
let arc2 = Arc::clone(&arc1);

thread::spawn(move || {
    println!("Arc in thread: {}", arc2);
});
```

### 10. 什么时候使用RefCell？

**答案：**
RefCell提供内部可变性，允许在不可变引用存在时修改数据，但会在运行时检查借用规则。

```rust
use std::cell::RefCell;
use std::rc::Rc;

struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

impl Node {
    fn new(value: i32) -> Rc<Self> {
        Rc::new(Node {
            value,
            children: RefCell::new(vec![]),
        })
    }
    
    fn add_child(&self, child: Rc<Node>) {
        // 即使self是不可变引用，也可以修改children
        self.children.borrow_mut().push(child);
    }
}
```

## 性能优化篇

### 11. 如何避免不必要的内存分配？

**答案：**
- 使用字符串切片`&str`而不是`String`
- 使用迭代器而不是收集到Vec
- 复用已分配的容器
- 使用`Cow`（Clone on Write）

```rust
use std::borrow::Cow;

// 避免不必要的String分配
fn process_string(s: &str) -> Cow<str> {
    if s.contains("bad") {
        Cow::Owned(s.replace("bad", "good"))
    } else {
        Cow::Borrowed(s)
    }
}

// 使用迭代器避免中间分配
fn sum_squares(nums: &[i32]) -> i32 {
    nums.iter()
        .map(|x| x * x)
        .filter(|&x| x > 10)
        .sum()  // 没有中间Vec
}
```

### 12. 解释零成本抽象的概念

**答案：**
零成本抽象意味着高级抽象不会带来运行时开销，编译器会将其优化为等价的手写代码。

```rust
// 迭代器是零成本抽象
let sum1: i32 = (0..1000).map(|x| x * x).sum();

// 等价于手写循环
let mut sum2 = 0;
for i in 0..1000 {
    sum2 += i * i;
}
// 编译后两者性能相同
```

## 实践应用篇

### 13. 如何在Rust中处理JSON？

**答案：**
使用serde库进行序列化和反序列化：

```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u32,
    email: Option<String>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
        email: Some("alice@example.com".to_string()),
    };
    
    // 序列化
    let json = serde_json::to_string(&person)?;
    println!("JSON: {}", json);
    
    // 反序列化
    let parsed: Person = serde_json::from_str(&json)?;
    println!("Parsed: {:?}", parsed);
    
    Ok(())
}
```

### 14. 如何实现一个简单的链表？

**答案：**
```rust
use std::rc::Rc;
use std::cell::RefCell;

type Link = Option<Rc<RefCell<Node>>>;

#[derive(Debug)]
struct Node {
    data: i32,
    next: Link,
}

#[derive(Debug)]
struct LinkedList {
    head: Link,
}

impl LinkedList {
    fn new() -> Self {
        LinkedList { head: None }
    }
    
    fn push(&mut self, data: i32) {
        let new_node = Rc::new(RefCell::new(Node {
            data,
            next: self.head.take(),
        }));
        self.head = Some(new_node);
    }
    
    fn pop(&mut self) -> Option<i32> {
        self.head.take().map(|old_head| {
            if let Ok(node) = Rc::try_unwrap(old_head) {
                let node = node.into_inner();
                self.head = node.next;
                node.data
            } else {
                panic!("Multiple references to head node");
            }
        })
    }
}
```

## 面试准备建议

### 常考知识点
1. 所有权、借用、生命周期
2. 错误处理（Result、Option）
3. 并发编程（线程安全）
4. 智能指针的使用
5. trait系统和泛型
6. 模式匹配
7. 闭包和迭代器
8. unsafe Rust的使用场景

### 编码题目类型
- 实现数据结构（链表、树等）
- 字符串处理
- 算法实现（排序、搜索）
- 并发编程问题
- 错误处理场景

### 面试技巧
- 先讲思路，再写代码
- 注意内存安全和性能
- 解释为什么选择特定的类型或方法
- 讨论权衡取舍（如Rc vs Arc）
- 展示对Rust生态的了解
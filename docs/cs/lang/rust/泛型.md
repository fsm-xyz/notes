Rust 的泛型展开是一个重要的编译时优化机制，让我详细解释一下静态展开（单态化）和相关概念。

## 静态展开（单态化 Monomorphization）

Rust 默认使用**静态展开**，也称为单态化。这意味着编译器会为每个具体的类型参数组合生成专门的代码版本。

### 工作原理

```rust
// 泛型函数定义
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    let x = add(5i32, 10i32);      // 生成 add_i32 版本
    let y = add(3.14f64, 2.86f64); // 生成 add_f64 版本
    let z = add(100u8, 200u8);     // 生成 add_u8 版本
}
```

编译后，实际上会生成三个不同的函数：
- 一个专门处理 `i32` 的版本
- 一个专门处理 `f64` 的版本  
- 一个专门处理 `u8` 的版本

### 优缺点

**优点：**
- **零成本抽象**：运行时没有额外开销
- **性能优化**：编译器可以针对具体类型进行内联和优化
- **类型安全**：在编译时就能发现类型错误

**缺点：**
- **代码膨胀**：每个类型组合都会生成新代码，增加二进制文件大小
- **编译时间**：需要为每个实例生成和优化代码

## 动态分派（Dynamic Dispatch）

虽然 Rust 主要使用静态展开，但也支持通过 trait object 实现动态分派：

```rust
trait Draw {
    fn draw(&self);
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Draw for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

fn main() {
    // 动态分派 - 使用 trait object
    let shapes: Vec<Box<dyn Draw>> = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 20.0 }),
    ];
    
    for shape in shapes {
        shape.draw(); // 通过虚函数表(vtable)调用
    }
}
```

### 动态分派特点：
- 使用 `dyn Trait` 创建 trait object
- 通过虚函数表（vtable）在运行时查找方法
- 有运行时开销但避免代码膨胀
- 适用于需要异构集合或插件系统的场景

## 控制单态化行为

### 1. 使用 `#[inline]` 属性
```rust
#[inline(always)]
fn generic_func<T>(x: T) -> T {
    x
}
```

### 2. 泛型参数约束
```rust
// 限制可能的类型，减少生成的代码量
fn process<T: Debug + Clone>(item: T) {
    println!("{:?}", item);
}
```

### 3. 混合使用静态和动态
```rust
// 静态分派的泛型函数
fn process_static<T: Draw>(item: T) {
    item.draw();
}

// 动态分派的函数
fn process_dynamic(item: &dyn Draw) {
    item.draw();
}
```

## 实际选择建议

1. **默认使用静态展开**：获得最佳性能
2. **考虑动态分派的场景**：
   - 需要存储不同类型的集合
   - 二进制大小受限
   - 插件系统或需要运行时多态
3. **性能关键路径**：始终使用静态展开
4. **库设计**：提供泛型 API，让用户选择

Rust 的这种设计让你可以根据具体需求在零成本抽象和运行时灵活性之间做出选择，这是 Rust 的一大优势。
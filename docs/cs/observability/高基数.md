# 高基数
-----

在 Elasticsearch (ES) 中，**高基数（High Cardinality）** 问题主要会影响 **聚合（aggregations）** 和 **内存使用**，尤其是当你试图对一个有大量唯一值的字段进行聚合时。

本质上，高基数字段的聚合操作需要将所有唯一的字段值加载到内存中，这会消耗大量的 JVM 堆内存。如果唯一值的数量非常大，可能会导致以下问题：

  * **内存溢出（OOM）**：当唯一值过多，超过了 JVM 堆内存的限制时，可能会导致节点崩溃。
  * **查询变慢**：即使没有内存溢出，大量的内存使用也会导致垃圾回收（Garbage Collection）变得频繁且耗时，从而显著降低查询性能。

### 解决方案

以下是解决 ES 高基数问题的几种方法：

#### 1\. 使用 `cardinality` 聚合

如果你只需要计算一个字段的唯一值数量，而不是对这些唯一值进行分组或统计，那么使用 **`cardinality` 聚合** 是最高效的方法。

`cardinality` 聚合使用 **HyperLogLog++** 算法，这是一种概率算法，可以在极低的内存消耗下，估算出一个字段的唯一值数量。它的计算结果是近似值，但通常非常精确，误差率在 1-2% 之间。

```json
GET /your_index/_search
{
  "size": 0,
  "aggs": {
    "unique_users": {
      "cardinality": {
        "field": "user_id"
      }
    }
  }
}
```

**优点：** 内存占用极低，速度快，适合需要粗略统计唯一值的场景。
**缺点：** 结果是近似值，不适合需要精确计数的场景。

-----

#### 2\. 使用 `composite` 聚合进行分页

如果你的聚合结果集非常庞大（例如，对高基数字段进行 `terms` 聚合），并且你只希望获取部分结果，那么使用 **`composite` 聚合** 是一个很好的选择。

`composite` 聚合允许你在聚合结果中进行**高效的分页**。它不会一次性加载所有唯一值到内存中，而是通过 `after` 参数来分批获取结果，从而避免了内存问题。这特别适合构建无限滚动的聚合结果列表。

```json
GET /your_index/_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_id": { "terms": { "field": "user_id" } } }
        ],
        "size": 100
      }
    }
  }
}
```

**优点：** 解决了内存问题，可以高效地对大型聚合结果进行分页。
**缺点：** 无法一次性获取所有聚合结果。

-----

#### 3\. 避免对高基数字段使用 `terms` 聚合

这是最根本的解决办法。**`terms` 聚合** 默认会尝试将所有唯一的桶（bucket）都加载到内存中进行计数，这正是高基数问题的根源。

  * **如果可能，重新设计你的数据模型**，避免对高基数字段进行聚合。例如，如果你需要对 `user_id` 进行聚合，但 `user_id` 是高基数字段，可以考虑在数据索引时，预先计算一些用户级别的统计数据，或者只在必要时才进行聚合。
  * \*\*使用 **`**keyword`** **类型**：确保你的高基数字段被设置为 `keyword` 类型，而不是 `text` 类型。`keyword` 字段不会被分词，可以进行精确匹配和聚合。`text` 字段虽然可以进行聚合，但性能非常差且不准确。

-----

### 总结

| 方法                 | 适用场景                               | 优缺点                                                                |
| -------------------- | -------------------------------------- | --------------------------------------------------------------------- |
| **`cardinality` 聚合** | **估算**一个字段的唯一值数量。         | **优点：** 内存占用极低，速度快。**缺点：** 结果是近似值。           |
| **`composite` 聚合** | 对高基数字段进行**高效分页**的聚合。   | **优点：** 解决了内存问题，适合分页。**缺点：** 无法一次性获取所有结果。 |
| **避免直接聚合** | 从根本上解决问题，改变数据模型或查询方式。 | **优点：** 治本，性能最优。**缺点：** 需要重新设计数据或应用逻辑。    |

在处理高基数问题时，最重要的是理解你的业务需求。如果你只需要一个近似值，`cardinality` 是最好的选择；如果你需要分页展示结果，`composite` 是理想方案；而如果你发现一个高基数字段的聚合是性能瓶颈，那么从数据模型层面进行优化通常是长期的解决方案。